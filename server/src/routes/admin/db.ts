import { NextFunction, Request, Response, Router } from "express";
import User from "../../db/models/user";
import Club from "../../db/models/club";
import Team from "../../db/models/team";
import SeasonTeam from "../../db/models/seasonTeam";
import Choreo, { MatType } from "../../db/models/choreo";
import UserService from "../../services/UserService";
import ClubService from "../../services/ClubService";
import TeamService from "../../services/TeamService";
import SeasonService from "../../services/SeasonService";
import Season from "../../db/models/season";
import MemberService from "../../services/MemberService";
import Member from "../../db/models/member";
import SeasonTeamService from "../../services/SeasonTeamService";
import ChoreoService from "../../services/ChoreoService";
import search from "../../utils/fuzzySearch";
import { sequelizeDataTypeToHtmlInputType } from "../../utils/datatypeConverter";

type entityList = { value: string, name: string }[]

const router = Router();

router.get("/", (req: Request, res: Response, next: NextFunction) => {
  res.render("../src/views/admin/db.ejs", {
    username: req.Admin.username,
  }); // njsscan-ignore: express_lfr_warning
  return next();
});

router.get("/:entity", async (req: Request, res: Response, next: NextFunction) => {
  const UserId = (req.query.UserId || null) as string;
  const searchTerm = req.query.s || null;

  let columns, data;
  let model;
  const extraData: { userList: entityList, clubList?: entityList, teamList?: entityList, seasonTeamList?: entityList, matTypeList?: entityList } = {
    userList: (await UserService.getAll()).map(
      (user: User) => ({ value: user.id, name: user.username })
    ),
  };
  switch (req.params.entity) {
    case "clubs":
      columns = ["name"];
      data = await ClubService.getAll(UserId, { all: !UserId });
      model = Club;
      break;
    case "teams":
      columns = ["name"];
      data = await TeamService.getAll(UserId, { all: !UserId });
      model = Team;
      extraData.clubList = (await ClubService.getAll(null, { all: true })).map(
        (club: Club) => ({ value: club.id, name: club.name })
      );
      break;
    case "seasons":
      columns = ["year", "name"];
      data = await SeasonService.getAll(UserId, { all: !UserId });
      model = Season;
      break;
    case "members":
      columns = ["name", "nickname", "abbreviation"];
      data = await MemberService.getAll(UserId, { all: !UserId });
      model = Member;
      extraData.teamList = (await TeamService.getAll(null, { all: true })).map(
        (team: Team) => ({ value: team.id, name: team.name })
      );
      extraData.seasonTeamList = (await SeasonTeamService.getAll())
        .filter((seasonTeam: SeasonTeam) => seasonTeam.User)
        .map((seasonTeam: SeasonTeam) => {
          return {
            value: seasonTeam.id,
            name: `${seasonTeam.User.username} - ${seasonTeam.Team.name} (${seasonTeam.Season?.name
              }${seasonTeam.Season?.year ? `, ${seasonTeam.Season?.year}` : ""})`,
          };
        });
      break;
    case "choreos":
      columns = ["name", "counts", "matType"];
      data = await ChoreoService.getAll(UserId, { all: !UserId });
      model = Choreo;
      extraData.seasonTeamList = (await SeasonTeamService.getAll())
        .filter((seasonTeam: SeasonTeam) => seasonTeam.User)
        .map((seasonTeam: SeasonTeam) => {
          return {
            value: seasonTeam.id,
            name: `${seasonTeam.User.username} - ${seasonTeam.Team.name} (${seasonTeam.Season?.name
              }${seasonTeam.Season?.year ? `, ${seasonTeam.Season?.year}` : ""})`,
          };
        });
      extraData.matTypeList = (Choreo.rawAttributes.matType.values as MatType[]).map(
        (matType) => ({
          value: matType,
          name: matType,
        })
      );
      break;
  }

  if (searchTerm) data = search(data, { keys: columns }, searchTerm);

  res.render("../src/views/admin/db.ejs", {
    username: req.Admin.username,
    columns,
    data,
    editColumns: JSON.stringify(
      Object.entries((model as { getAttributes: () => Record<string, { _autoGenerated?: boolean }> }).getAttributes())
        .filter(([key, value]) => !(value._autoGenerated || key == "id"))
        .map(([key, value]) => ({
          column: key,
          type: sequelizeDataTypeToHtmlInputType((value as { type: { key: string } }).type),
        }))
    ),
    entity: req.params.entity,
    ...extraData,
  }); // njsscan-ignore: express_lfr_warning

  return next();
});

router.post("/:entity", async (req: Request, res: Response, next: NextFunction) => {
  const { entity } = req.params;
  const data = req.body;

  // Sanitize data to remove empty strings and convert "null" strings to null
  Object.keys(data).forEach((key) => {
    if (data[key] === "") {
      delete data[key];
    } else if (data[key] === "null") {
      data[key] = null;
    }
  });

  try {
    switch (entity) {
      case "clubs":
        {
          const { name, UserId } = data;
          await ClubService.create(name, UserId);
        }
        break;
      case "teams":
        {
          const { name, ClubId, SeasonId, UserId } = data;
          await TeamService.create(name, ClubId, SeasonId, UserId);
        }
        break;
      case "seasons":
        {
          const { name, year, UserId } = data;
          await SeasonService.create(name, year, UserId);
        }
        break;
      case "members":
        {
          const { name, nickname, abbreviation, SeasonTeamId, UserId } = data;
          await MemberService.create(
            name,
            nickname,
            abbreviation,
            SeasonTeamId,
            UserId
          );
        }
        break;
      case "choreos":
        {
          const { name, counts, matType, SeasonTeamId, UserId } = data;
          await ChoreoService.create(
            name,
            counts,
            matType,
            SeasonTeamId,
            [],
            UserId
          );
        }
        break;
      default:
        return next(new Error(req.t("errors.invalid-entity")));
    }

    res.redirect(`${req.baseUrl}/${entity}`); // njsscan-ignore: express_open_redirect
  } catch (e) {
    next(e);
  }
});

router.post("/:entity/update", async (req: Request, res: Response, next: NextFunction) => {
  const { entity } = req.params;
  const { id, ...data } = req.body;

  // Sanitize data to remove empty strings and convert "null" strings to null
  Object.keys(data).forEach((key) => {
    if (data[key] === "") {
      delete data[key];
    } else if (data[key] === "null") {
      data[key] = null;
    }
  });

  let service;
  switch (entity) {
    case "clubs":
      service = ClubService;
      break;
    case "teams":
      service = TeamService;
      break;
    case "seasons":
      service = SeasonService;
      break;
    case "members":
      service = MemberService;
      break;
    case "choreos":
      service = ChoreoService;
      break;
    default:
      return next(new Error(req.t("errors.invalid-entity")));
  }
  try {
    await service.update(id, data, null, { all: true });
    res.redirect(`${req.baseUrl}/${entity}`); // njsscan-ignore: express_open_redirect
  } catch (e) {
    next(e);
  }
});

router.delete("/:entity/:id", async (req: Request, res: Response, next: NextFunction) => {
  const { entity, id } = req.params;

  let service;
  switch (entity) {
    case "clubs":
      service = ClubService;
      break;
    case "teams":
      service = TeamService;
      break;
    case "seasons":
      service = SeasonService;
      break;
    case "members":
      service = MemberService;
      break;
    case "choreos":
      service = ChoreoService;
      break;
    default:
      return next(new Error(req.t("errors.invalid-entity")));
  }

  try {
    await service.remove(id, null, { all: true });
    res.redirect(`${req.baseUrl}/${entity}`); // njsscan-ignore: express_open_redirect
  } catch (e) {
    next(e);
  }
});

export { router as dbRouter };
